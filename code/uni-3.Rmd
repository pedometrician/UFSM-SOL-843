---
title: "Unidade III -- Modelo Linear Misto de Variação Espacial"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../docs") })
output: 
  bookdown::html_document2:
    css: styles.css
lang: pt
---

<div id="summary">
**Temas**: Modelo linear misto de variação espacial.
</div>

# Definição e propriedades

Segundo o modelo linear misto de variação espacial, o valor de uma variável ambiental, $Y$, em um local qualquer no espaço, $\boldsymbol{s}$, é resultado da adição de efeitos fixos e efeitos aleatórios.

$$Y(\boldsymbol{s}) = Z(\boldsymbol{s}) + \varepsilon(\boldsymbol{s}) = \boldsymbol{x}(\boldsymbol{s})^\text{T}\boldsymbol{\beta} + B(\boldsymbol{s}) + \varepsilon(\boldsymbol{s})$$

Na equação acima, $Z(\boldsymbol{s}) = \boldsymbol{x}(\boldsymbol{s})^\text{T}\boldsymbol{\beta} + B(\boldsymbol{s})$ é o chamado sinal,
enquanto $\varepsilon(\boldsymbol{s})$ é um resíduo (ou ruído) independente e identicamente distribuído (i.i.d.), possivelmente descrito
por uma distribuição Gaussina de probabilidade. O sinal da variável ambiental, $Z(\boldsymbol{s})$, possui dois componentes. O primeiro,
$\boldsymbol{x}(\boldsymbol{s})^\text{T}\boldsymbol{\beta}$ representa os efeitos fixos, ou seja, a tendência espacial de origem
desterminística, especificamente, a relação de dependência (causa e efeito) entre as covariáveis ambientais, $\boldsymbol{x}$, e a
variável ambiental, $Y$, onde $\boldsymbol{\beta}$ são os coeficientes da regressão linear, e $\text{T}$ denota transposição. O segundo
componente do sinal da variável ambiental, $B(\boldsymbol{s})$, representa os efeitos aleatórios, ou seja, a parte da variação da variável
ambiental explicada estocasticamente, nesse caso usando um campo Gaussiano estacionário e autocorrelacionado não-observável (processo ou variável latente), cuja média é igual a zero.

A partir do conjunto finito $n$ de observações espaciais da variável ambiental, 
$\boldsymbol{y}^\text{T} = \{y(\boldsymbol{s}_1), y(\boldsymbol{s}_2), \ldots, y(\boldsymbol{s}_n)\}$, nossa inteção é estimar os coeficientes da regressão linear, $\boldsymbol{\beta}$, os parâmetros da função de covariância (ou variograma), 
$\boldsymbol{\theta}^\text{T} = (\tau^2, \alpha)$, $\sigma^2$ a fim de que seja possível predizer 


# Função de covariância Whittle-Matérn

Um processo espacial Gaussiano é um tipo de processo que pode ser completamente especificado pela sua *função de média*, $\mu(\boldsymbol{s}) = \text{E}[Z(\boldsymbol{s})]$, e sua *função de covariância*, $\gamma(\boldsymbol{s}_i, \boldsymbol{s}_j) = \text{Cov}\{Z(\boldsymbol{s}_i), Z(\boldsymbol{s}_j)\}$. Esse processo Gaussiano será *estacionário* se $\mu(\boldsymbol{s}) = \mu$, ou seja, se a média for constante para todos os $\boldsymbol{s}$, e se $\gamma(\boldsymbol{s}_i, \boldsymbol{s}_j) = \gamma(u)$, onde $u = \boldsymbol{s}_i - \boldsymbol{s}_j$, ou seja, a covariância depende apenas do vetor de diferença entre os locais $\boldsymbol{s}_i$ e $\boldsymbol{s}_j$.

A especificação da estrutura de covariância de um processo espacial autocorrelacionado influencia diretamente a suavidade da superfície gerada por esse processo. O parâmetro $\nu$ da função de covariância Whittle-Matérn, chamado de parâmetro de suavidade, confere à essa função grande flexibilidade para modelar processos espaciais autocorrelacionado. Quando $\nu$ é pequeno, ou seja, $\nu \to 0$, significa que o processo espacial é rugoso. Do contrário, quando $\nu$ é grande, ou seja, $\nu \to \infty$, então o processo espacial é suave. 

$$\gamma(h) = \left\{2^{\nu-1} \Gamma(\nu)\right\}^{-1} (h/\alpha)^\nu K_\nu(h/\alpha)$$

A flexibilidade da função de covariância Whittle-Matérn, conferida pelo seu parâmetro de suavidade, $\nu$, permite que ela seja considerada um generalização de um grande número de modelos teóricos do variograma.

Se $\nu \to \infty$, então a função de  pode ser considerada equivalente à função de covariância Gaussiana. Quando $\nu \to 1$, ela corresponde à função de covariância de Whittle. Quando $\nu = 0.5$, então é o mesmo que a função exponencial.

# Método da máxima verossimilhança restrita

$$L(\boldsymbol{\beta}, \sigma^2, \boldsymbol{\theta}, \boldsymbol{z} | \boldsymbol{y}) = - \frac{1}{2} \log(\det(\sigma^2\boldsymbol{I} + \boldsymbol{V}_{\boldsymbol{\theta}})) - \frac{1}{2}$$

# Exercício

```{r, message=FALSE, warning=FALSE}
# Pacotes
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(latticeExtra)

# Sistemas de referência de coordenadas (Fonte: http://spatialreference.org/ref/epsg/)
wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sirgas2000 <- sp::CRS('+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs')

# Rampas de cores
col_soil_var <- topo.colors(100)
```

Vamos descarregar os arquivos do mapa pedológico para um diretório local. O nome desse diretório é definido abaixo pelo objeto `data_folder`. Altere o caminho para esse diretório conforme necessário. Caso você já tenha descarregado os arquivos do mapa pedológico, então `data_folder` deve ser o caminho para o diretório onde esses arquivos se encontram.

```{r}
data_folder <- '../data/'
ext <- c('dbf', 'prj', 'shp', 'shx')
files <- c(glue('pedologia25.{ext}'), glue('geologia50.{ext}'))
download <- !all(files %in% list.files(data_folder))
if (download) {
  url <- 'https://github.com/samuel-rosa/UFSM-SOL-843/tree/master/data/'
  url <- glue('{url}{files}')
  destfile <- glue('{data_folder}{files}')
  for (i in 1:length(files)) {
    download.file(url = url[i], destfile = destfile[i])
  }
}
```

Agora você já pode carregar o mapa pedológico para o seu ambiente de trabalho. Para isso, use a função `raster::shapefile`. Note que se o sistema operacional do seu computador for o MS Windows, pode ser necessário incluir o o argumento `encoding = 'UTF-8'` na função `raster::shapefile` para garantir que os carácteres especiais usados nos nomes das unidades de mapeamento seja reconhecidos. Verifique se a estrutura de `pedologia25` está conforme o esperado para um objeto do tipo `SpatialPolygonsDataFrame`. Note que a função `sp::spTransform` é usada para projetar as coordenadas original no plano cartesiano (UTM).

```{r}
pedologia25 <- 
  glue('{data_folder}pedologia25.shp') %>% 
  raster::shapefile(stringsAsFactors = TRUE) %>% 
  sp::spTransform(wgs84utm22s)
col_soil_um <- terrain.colors(nlevels(pedologia25$um))
str(pedologia25, 2)
```

```{r}
geologia50 <- 
  glue('{data_folder}geologia50.shp') %>% 
  raster::shapefile(stringsAsFactors = TRUE) %>% 
  sp::spTransform(wgs84utm22s)
col_geo_um <- topo.colors(nlevels(geologia50$geo))
str(geologia50, 2)
```

```{r, message=FALSE, warning=FALSE}
pontos400_o <- febr::observations('ctb0003', which.cols = 'all', progress = FALSE)
pontos400_l <- febr::layers('ctb0003', which.cols = 'all', missing.data = 'keep', progress = FALSE)
id <- c('dataset_id', 'observacao_id')
pontos400 <- 
  merge(pontos400_o, pontos400_l, by.x = id, by.y = id) %>% 
  select(observacao_id, coord_x, coord_y, taxon_sibcs_2009, ca_kcl_aas, argila_, areia_)
rm(pontos400_l, pontos400_o)
sp::coordinates(pontos400) <- ~ coord_x + coord_y
sp::proj4string(pontos400) <- sirgas2000
pontos400 <- sp::spTransform(pontos400, wgs84utm22s)
pontos400$um <- sp::over(x = pontos400, y = pedologia25) %>% unlist()
pontos400$geo <- sp::over(x = pontos400, y = geologia50) %>% unlist()
pontos400in <- pontos400[!is.na(pontos400$um) & !is.na(pontos400$geo), ]
```

```{r pts400-in, eval=FALSE, fig.cap='Distribuição espacial das 376 observações localizadas dentro dos limites da área de estudo.'}
sp::spplot(
  pedologia25, col.regions = col_soil_um, alpha.regions = 0.3, colorkey = FALSE) +
  latticeExtra::as.layer(
    lattice::xyplot(coord_y ~ coord_x, data = as.data.frame(pontos400in@coords), col = 'red', pch = 17))
```

```{r, eval=FALSE, fig.cap='Distribuição espacial das 376 observações localizadas dentro dos limites da área de estudo.'}
sp::spplot(
  geologia50, col.regions = col_geo_um, alpha.regions = 0.5, colorkey = FALSE) +
  latticeExtra::as.layer(
    lattice::xyplot(coord_y ~ coord_x, data = as.data.frame(pontos400in@coords), col = 'red', pch = 17))
```

## Análise exploratória

```{r lm-fit}
lm_fit <- lm(areia_ ~ um + geo, pontos400in)
summary(lm_fit)
```

A Figura \@ref(fig:lm-residuos) mostra os resíduos da regressão linear ajustada aos dados do conteúdo de areia.

```{r lm-residuos, fig.asp=1}
op <- par(mfrow = c(2, 2))
plot(lm_fit, which = 1:4)
par(op)
```

Conforme mostra a Figura \@ref(fig:vario-direction), os resíduos da regressão linear possuem dependência espacial. Partindo da primeira classe de distância de separação, a semivariância aumenta de maneira relativamente rápida e atinge certa estabilidade a partir de 1000-1500 m. Avaliada a evolução da semivariância nas diferentes direções, principalmente nas primeiras classes de distância de separação, não há evidência clara da existência de estruturas de autocorrelação espacial dependentes da direção. Assim, é possível assumir que o processo espacial é isotrópico (do contrário seria chamado anisotrópico).

```{r vario-direction, fig.asp=1, fig.cap='Variograma direcional dos resíduos do modelo linear do conteúdo de areia na camada superficial do solo.'}
limites <- seq(0, 1500, length.out = 15)
residuals(lm_fit) %>% 
  georob::sample.variogram(
    locations = pontos400in@coords, lag.dist.def = limites,
    xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
  plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)')
```

Assumida a isotropia do processo espacial, podemos computar o semivariograma amostral omnidirecional (ou independente da direção). Em seguida, vamos ajustar ao variograma amostral um modelo exponencial do variograma. Para isso usamos o método dos quadrados mínimos não-lineares ponderados, sendo a ponderação definida conforme o método de Cressie (1993, sec. 2.6.2). O processo de estimativa dos parâmetros do modelo exponencial do variograma é conduzido via otimização usando a função `stats::optim(method = "BFGS")`. Os valores produzidos pelo otimizador a cada 10 iterações são impressos no console.

```{r, fig.asp=1, message=FALSE, warning=FALSE}
vario <- 
  residuals(lm_fit) %>% 
  georob::sample.variogram(
    locations = pontos400in@coords, lag.dist.def = limites)
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 20000, nugget = 2000, scale = 500), 
  weighting.method = "cressie", method = "BFGS")
```

O ajuste do modelo exponencial ao variograma amostral dos resíduos do conteúdo de areia é mostrado na Figura \@ref(fig:vario-exp). Note como a curva ajustada passa pelo centro de massa dos doze pontos do variograma amostral, uma característica do método dos quadrados mínimos.

```{r vario-exp, fig.asp=1, fig.cap='Variograma amostral (preto) dos resíduos do modelo linear do conteúdo de areia na camada superficial do solo e a função exponencial (vermelho) a ele ajustada.'}
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
```

Os parâmetros ajustados do modelo exponencial do variograma são mostrados abaixo. Note que o otimizador precisou de `r vario_fit$iter[1]` iterações para convergir, ou seja, encontrar os valores ótimos -- ótimo condicional aos dados -- para o modelo exponencial. Um diferencial do pacote **georob** -- comparado ao pacote **gestat** -- é que o mesmo retorna, além dos parâmetros estimados, os limites inferior (`Lower`) e superior (`Upper`) de confiança dessas estimativas. Note como o intervalo de confiança da estimativa da variância residual (`nugget`), $\tau^2$.

```{r}
summary(vario_fit)
```

## (RE)ML Gaussiano

```{r}
reml_fit <- georob::georob(
  areia_ ~ um + geo, pontos400in, locations = ~ coord_x + coord_y, variogram.model = 'RMexp', 
  param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
            nugget = vario_fit$variogram.object[[1]]$param[['nugget']], 
            scale = vario_fit$variogram.object[[1]]$param[['scale']]),
  tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(reml_fit)
```

```{r vario-reml, fig.asp=1, fig.cap='Variograma amostral (preto) dos resíduos do modelo linear do conteúdo de areia na camada superficial do solo e a função exponencial (vermelho) a ele ajustada.'}
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
lines(reml_fit, col = "blue", lty = 'dashed')
```

```{r}
reml_fit_prof <- georob::profilelogLik(reml_fit, values = data.frame(scale = seq(50, 350, by = 10)))
```

```{r loglik-scale, fig.asp=1, fig.cap='Perfil da função logarítmica da verossimilhança restrita para o parâmetro alcance (`scale`). A linhas verticais representam a estimativa e intervalo de confiança do parâmetro alcance. A interseção entre a linha horizontal e o perfil indica a região de 95% de confiança para o parâmetro alcance segundo o teste da razão de verossimilhança.'}
plot(loglik ~ scale, reml_fit_prof, type = "l")
abline(v = summary(reml_fit)$param.aniso[[1]]['scale', ], lty = c("dashed", rep('dotted', 2)), col = 'red')
abline(h = reml_fit$loglik - 0.5 * qchisq(0.95, 1), lty = "dotted")
```

```{r, fig.width=14, fig.height=7, fig.cap='Relação das estimativas da variância parcial (`variance`) e da variância residual (`nugget`) com as estimativas do alcance (`scale`).'}
op <- par(mfrow = c(1, 2))
plot(variance ~ scale, reml_fit_prof, ylim = c(0, max(variance)), type = "l")
plot(nugget ~ scale, reml_fit_prof, ylim = c(0, max(nugget)), type = "l")
par(op)
```

